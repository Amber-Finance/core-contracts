{
  "contract_name": "mars-perps",
  "contract_version": "2.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The perp protocol's global configuration",
    "type": "object",
    "required": [
      "base_denom",
      "cooldown_period",
      "credit_manager",
      "min_position_value",
      "oracle"
    ],
    "properties": {
      "base_denom": {
        "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
        "type": "string"
      },
      "cooldown_period": {
        "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "credit_manager": {
        "description": "Address of the Mars Rover credit manager (CM) contract.\n\nUsers open, modify, or close perp positions by interacting with the CM. The CM then invokes the appropriate execute method(s) on the perps contract to fulfill the user requests.",
        "type": "string"
      },
      "min_position_value": {
        "description": "The minimum value of a position, in the base asset (i.e. USDC).",
        "allOf": [
          {
            "$ref": "#/definitions/Uint128"
          }
        ]
      },
      "oracle": {
        "description": "Adapter for interacting with the Mars oracle contract",
        "allOf": [
          {
            "$ref": "#/definitions/OracleBase_for_String"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "OracleBase_for_String": {
        "type": "string"
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "update_owner"
        ],
        "properties": {
          "update_owner": {
            "$ref": "#/definitions/OwnerUpdate"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Init a denom to be traded.\n\nOnly callable by the owner.",
        "type": "object",
        "required": [
          "init_denom"
        ],
        "properties": {
          "init_denom": {
            "type": "object",
            "required": [
              "denom",
              "max_funding_velocity",
              "skew_scale"
            ],
            "properties": {
              "denom": {
                "type": "string"
              },
              "max_funding_velocity": {
                "$ref": "#/definitions/Decimal"
              },
              "skew_scale": {
                "$ref": "#/definitions/Decimal"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enable a denom to be traded.\n\nOnly callable by the owner.",
        "type": "object",
        "required": [
          "enable_denom"
        ],
        "properties": {
          "enable_denom": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Disable a denom from being traded.\n\nOnce disabled, perp positions with this denom can only be closed.\n\nOnly callable by the owner.",
        "type": "object",
        "required": [
          "disable_denom"
        ],
        "properties": {
          "disable_denom": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Provide liquidity of the base token to the vault.\n\nMust send exactly one coin of `base_denom`.\n\nThe deposited tokens will be used to settle perp trades. liquidity providers win if traders have negative PnLs, or loss if traders have positive PnLs.",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unlock liquidity from the vault. The unlocked tokens will have to wait a cooldown period before they can be withdrawn.",
        "type": "object",
        "required": [
          "unlock"
        ],
        "properties": {
          "unlock": {
            "type": "object",
            "required": [
              "shares"
            ],
            "properties": {
              "shares": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw liquidity from the vault.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Open a new perp position.\n\nOnly callable by Rover credit manager.\n\nMust send exactly one coin of `base_denom`.",
        "type": "object",
        "required": [
          "open_position"
        ],
        "properties": {
          "open_position": {
            "type": "object",
            "required": [
              "account_id",
              "denom",
              "size"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID",
                "type": "string"
              },
              "denom": {
                "description": "Name of the trading pair",
                "type": "string"
              },
              "size": {
                "description": "Size of the position, denominated in the traded asset.\n\nA positive number means the position is long, a negative number means it's short.\n\nMust be greater than the minimum position size set at the protocol level.",
                "allOf": [
                  {
                    "$ref": "#/definitions/SignedDecimal"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Close a perp position. Return collateral + unrealized PnL to the user's credit account.\n\nOnly callable by Rover credit manager.",
        "type": "object",
        "required": [
          "close_position"
        ],
        "properties": {
          "close_position": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "OwnerUpdate": {
        "oneOf": [
          {
            "description": "Proposes a new owner to take role. Only current owner can execute.",
            "type": "object",
            "required": [
              "propose_new_owner"
            ],
            "properties": {
              "propose_new_owner": {
                "type": "object",
                "required": [
                  "proposed"
                ],
                "properties": {
                  "proposed": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the currently proposed owner. Only current owner can execute.",
            "type": "string",
            "enum": [
              "clear_proposed"
            ]
          },
          {
            "description": "Promotes the proposed owner to be the current one. Only the proposed owner can execute.",
            "type": "string",
            "enum": [
              "accept_proposed"
            ]
          },
          {
            "description": "Throws away the keys to the Owner role forever. Once done, no owner can ever be set later.",
            "type": "string",
            "enum": [
              "abolish_owner_role"
            ]
          },
          {
            "description": "A separate entity managed by Owner that can be used for granting specific emergency powers.",
            "type": "object",
            "required": [
              "set_emergency_owner"
            ],
            "properties": {
              "set_emergency_owner": {
                "type": "object",
                "required": [
                  "emergency_owner"
                ],
                "properties": {
                  "emergency_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove the entity in the Emergency Owner role",
            "type": "string",
            "enum": [
              "clear_emergency_owner"
            ]
          }
        ]
      },
      "SignedDecimal": {
        "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
        "type": "object",
        "required": [
          "abs",
          "negative"
        ],
        "properties": {
          "abs": {
            "$ref": "#/definitions/Decimal"
          },
          "negative": {
            "type": "boolean"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "vault_state"
        ],
        "properties": {
          "vault_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_state"
        ],
        "properties": {
          "denom_state": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp denom state with current calculated PnL, funding etc.",
        "type": "object",
        "required": [
          "perp_denom_state"
        ],
        "properties": {
          "perp_denom_state": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List all denoms enabled for trading",
        "type": "object",
        "required": [
          "denom_states"
        ],
        "properties": {
          "denom_states": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the amount of deposit made to the vault by a single user",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "required": [
              "depositor"
            ],
            "properties": {
              "depositor": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List all deposits to the vault",
        "type": "object",
        "required": [
          "deposits"
        ],
        "properties": {
          "deposits": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unlocks"
        ],
        "properties": {
          "unlocks": {
            "type": "object",
            "required": [
              "depositor"
            ],
            "properties": {
              "depositor": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp position by ID",
        "type": "object",
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all accounts and denoms",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all denoms that belong to a specific credit account.\n\nNOTE: This query does not take a pagination parameter. It always returns _all_ perp positions that belong to the given account.",
        "type": "object",
        "required": [
          "positions_by_account"
        ],
        "properties": {
          "positions_by_account": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Compute the total PnL of all perp positions, denominated in uusd (USD = 1e6 uusd, configured in Oracle)",
        "type": "object",
        "required": [
          "total_pnl"
        ],
        "properties": {
          "total_pnl": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config_for_String",
      "description": "The perp protocol's global configuration",
      "type": "object",
      "required": [
        "base_denom",
        "cooldown_period",
        "credit_manager",
        "min_position_value",
        "oracle"
      ],
      "properties": {
        "base_denom": {
          "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
          "type": "string"
        },
        "cooldown_period": {
          "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "credit_manager": {
          "description": "Address of the Mars Rover credit manager (CM) contract.\n\nUsers open, modify, or close perp positions by interacting with the CM. The CM then invokes the appropriate execute method(s) on the perps contract to fulfill the user requests.",
          "type": "string"
        },
        "min_position_value": {
          "description": "The minimum value of a position, in the base asset (i.e. USDC).",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "oracle": {
          "description": "Adapter for interacting with the Mars oracle contract",
          "allOf": [
            {
              "$ref": "#/definitions/OracleBase_for_String"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "OracleBase_for_String": {
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "denom_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DenomStateResponse",
      "type": "object",
      "required": [
        "denom",
        "enabled",
        "funding",
        "last_updated",
        "total_cost_base",
        "total_size"
      ],
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "funding": {
          "$ref": "#/definitions/Funding"
        },
        "last_updated": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "total_cost_base": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "total_size": {
          "$ref": "#/definitions/SignedDecimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "accumulated_size_weighted_by_index",
            "constant_factor",
            "index",
            "max_funding_velocity",
            "rate",
            "skew_scale"
          ],
          "properties": {
            "accumulated_size_weighted_by_index": {
              "description": "The accumulated size weighted by the index, calculated for open positions as: pos_1_size / pos_1_index + pos_2_size / pos_2_index + ... if a position is closed, the accumulated position is removed from the accumulator: pos_1_size / pos_1_index + pos_2_size / pos_2_index + ... - pos_1_size / pos_1_index pos_2_size / pos_2_index + ...",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "constant_factor": {
              "description": "The constant_factor: max_funding_velocity / skew_scale",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "index": {
              "description": "The current funding index calculated as: index = prev_index * (1 + current_rate)",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "rate": {
              "description": "The current funding rate calculated as an 24-hour rate. It is calculated as: rate = prev_rate + (funding_rate_velocity * (current_time_sec - prev_time_sec) / (ONE_DAY_SEC))",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew, as per the function: funding_rate_velocity = max_funding_velocity * skew / skew_scale The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "denom_states": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_DenomStateResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/DenomStateResponse"
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "DenomStateResponse": {
          "type": "object",
          "required": [
            "denom",
            "enabled",
            "funding",
            "last_updated",
            "total_cost_base",
            "total_size"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "enabled": {
              "type": "boolean"
            },
            "funding": {
              "$ref": "#/definitions/Funding"
            },
            "last_updated": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "total_cost_base": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "total_size": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "accumulated_size_weighted_by_index",
            "constant_factor",
            "index",
            "max_funding_velocity",
            "rate",
            "skew_scale"
          ],
          "properties": {
            "accumulated_size_weighted_by_index": {
              "description": "The accumulated size weighted by the index, calculated for open positions as: pos_1_size / pos_1_index + pos_2_size / pos_2_index + ... if a position is closed, the accumulated position is removed from the accumulator: pos_1_size / pos_1_index + pos_2_size / pos_2_index + ... - pos_1_size / pos_1_index pos_2_size / pos_2_index + ...",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "constant_factor": {
              "description": "The constant_factor: max_funding_velocity / skew_scale",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "index": {
              "description": "The current funding index calculated as: index = prev_index * (1 + current_rate)",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "rate": {
              "description": "The current funding rate calculated as an 24-hour rate. It is calculated as: rate = prev_rate + (funding_rate_velocity * (current_time_sec - prev_time_sec) / (ONE_DAY_SEC))",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew, as per the function: funding_rate_velocity = max_funding_velocity * skew / skew_scale The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "deposit": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DepositResponse",
      "type": "object",
      "required": [
        "amount",
        "depositor",
        "shares"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "depositor": {
          "type": "string"
        },
        "shares": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "deposits": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_DepositResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/DepositResponse"
      },
      "definitions": {
        "DepositResponse": {
          "type": "object",
          "required": [
            "amount",
            "depositor",
            "shares"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "depositor": {
              "type": "string"
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OwnerResponse",
      "description": "Returned from Owner.query()",
      "type": "object",
      "required": [
        "abolished",
        "initialized"
      ],
      "properties": {
        "abolished": {
          "type": "boolean"
        },
        "emergency_owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "initialized": {
          "type": "boolean"
        },
        "owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "proposed": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "perp_denom_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PerpDenomState",
      "description": "This is the denom data to be returned in a query. It includes current price, PnL and funding.",
      "type": "object",
      "required": [
        "constant_factor",
        "denom",
        "enabled",
        "index",
        "pnl_values",
        "rate",
        "total_cost_base",
        "total_size"
      ],
      "properties": {
        "constant_factor": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "index": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "pnl_values": {
          "$ref": "#/definitions/PnlValues"
        },
        "rate": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "total_cost_base": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "total_size": {
          "$ref": "#/definitions/SignedDecimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PnlValues": {
          "description": "PnL values denominated in the base currency",
          "type": "object",
          "required": [
            "accrued_funding",
            "pnl",
            "unrealized_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "pnl": {
              "description": "The total PnL: unrealized PnL - accrued funding",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "unrealized_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "position": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionResponse",
      "type": "object",
      "required": [
        "account_id",
        "position"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "position": {
          "$ref": "#/definitions/PerpPosition"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_price",
            "denom",
            "entry_price",
            "pnl",
            "size",
            "unrealised_funding_accrued"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "pnl": {
              "$ref": "#/definitions/PnL"
            },
            "size": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "unrealised_funding_accrued": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "PnL": {
          "description": "The profit-and-loss of a perp position, denominated in the base currency.",
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "break_even"
              ]
            },
            {
              "type": "object",
              "required": [
                "profit"
              ],
              "properties": {
                "profit": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "loss"
              ],
              "properties": {
                "loss": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PositionResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PositionResponse"
      },
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_price",
            "denom",
            "entry_price",
            "pnl",
            "size",
            "unrealised_funding_accrued"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "pnl": {
              "$ref": "#/definitions/PnL"
            },
            "size": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "unrealised_funding_accrued": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "PnL": {
          "description": "The profit-and-loss of a perp position, denominated in the base currency.",
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "break_even"
              ]
            },
            {
              "type": "object",
              "required": [
                "profit"
              ],
              "properties": {
                "profit": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "loss"
              ],
              "properties": {
                "loss": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PositionResponse": {
          "type": "object",
          "required": [
            "account_id",
            "position"
          ],
          "properties": {
            "account_id": {
              "type": "string"
            },
            "position": {
              "$ref": "#/definitions/PerpPosition"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions_by_account": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionsByAccountResponse",
      "type": "object",
      "required": [
        "account_id",
        "positions"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "positions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PerpPosition"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_price",
            "denom",
            "entry_price",
            "pnl",
            "size",
            "unrealised_funding_accrued"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "pnl": {
              "$ref": "#/definitions/PnL"
            },
            "size": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "unrealised_funding_accrued": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "PnL": {
          "description": "The profit-and-loss of a perp position, denominated in the base currency.",
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "break_even"
              ]
            },
            {
              "type": "object",
              "required": [
                "profit"
              ],
              "properties": {
                "profit": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "loss"
              ],
              "properties": {
                "loss": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "total_pnl": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SignedDecimal",
      "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
      "type": "object",
      "required": [
        "abs",
        "negative"
      ],
      "properties": {
        "abs": {
          "$ref": "#/definitions/Decimal"
        },
        "negative": {
          "type": "boolean"
        }
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "unlocks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_UnlockState",
      "type": "array",
      "items": {
        "$ref": "#/definitions/UnlockState"
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "UnlockState": {
          "description": "Unlock state for a single user",
          "type": "object",
          "required": [
            "amount",
            "cooldown_end",
            "created_at"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "cooldown_end": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "vault_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VaultState",
      "description": "Global state of the counterparty vault",
      "type": "object",
      "required": [
        "total_liquidity",
        "total_shares"
      ],
      "properties": {
        "total_liquidity": {
          "$ref": "#/definitions/Uint128"
        },
        "total_shares": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
