{
  "contract_name": "mars-perps",
  "contract_version": "2.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The perp protocol's global configuration",
    "type": "object",
    "required": [
      "address_provider",
      "base_denom",
      "cooldown_period",
      "credit_manager",
      "max_positions",
      "oracle",
      "params",
      "protocol_fee_rate",
      "target_vault_collaterization_ratio"
    ],
    "properties": {
      "address_provider": {
        "description": "Address provider returns addresses for all protocol contracts",
        "type": "string"
      },
      "base_denom": {
        "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
        "type": "string"
      },
      "cooldown_period": {
        "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "credit_manager": {
        "description": "Address of the Mars Rover credit manager (CM) contract.\n\nUsers open, modify, or close perp positions by interacting with the CM. The CM then invokes the appropriate execute method(s) on the perps contract to fulfill the user requests.",
        "type": "string"
      },
      "max_positions": {
        "description": "The maximum number of positions that can be opened by a single user",
        "type": "integer",
        "format": "uint8",
        "minimum": 0.0
      },
      "oracle": {
        "description": "Adapter for interacting with the Mars oracle contract",
        "allOf": [
          {
            "$ref": "#/definitions/OracleBase_for_String"
          }
        ]
      },
      "params": {
        "description": "Adapter for interacting with the Mars params contract",
        "allOf": [
          {
            "$ref": "#/definitions/ParamsBase_for_String"
          }
        ]
      },
      "protocol_fee_rate": {
        "description": "The percentage of fees that is directed to the protocol",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "target_vault_collaterization_ratio": {
        "description": "The target collateralization ratio of the vault",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "OracleBase_for_String": {
        "type": "string"
      },
      "ParamsBase_for_String": {
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "update_owner"
        ],
        "properties": {
          "update_owner": {
            "$ref": "#/definitions/OwnerUpdate"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Provide liquidity of the base token to the vault.\n\nMust send exactly one coin of `base_denom`.\n\nThe deposited tokens will be used to settle perp trades. liquidity providers win if traders have negative PnLs, or loss if traders have positive PnLs.",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unlock liquidity from the vault. The unlocked tokens will have to wait a cooldown period before they can be withdrawn.",
        "type": "object",
        "required": [
          "unlock"
        ],
        "properties": {
          "unlock": {
            "type": "object",
            "required": [
              "shares"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "shares": {
                "description": "The amount of shares to unlock",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw liquidity from the vault.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Execute a perp order against a perp market for a given account. If the position in that market for that account id exists, it is modified. If no position exists, a position is created (providing reduce_only is none or false)",
        "type": "object",
        "required": [
          "execute_perp_order"
        ],
        "properties": {
          "execute_perp_order": {
            "type": "object",
            "required": [
              "account_id",
              "denom",
              "size"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "reduce_only": {
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "size": {
                "$ref": "#/definitions/SignedUint"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Close all perp positions. Use this to liquidate a user's credit account.\n\nOnly callable by Rover credit manager.",
        "type": "object",
        "required": [
          "close_all_positions"
        ],
        "properties": {
          "close_all_positions": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "action": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ActionKind"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Deleveraging a vault by closing a position for an account. This process helps to increase the Collateralization Ratio (CR) of the vault and/or decrease the maximum Open Interest (max OI) values (`long_oi_value` and `short_oi_value`).\n\nThe highest unrealized PnL should be closed first. In cases where the maximum OI is exceeded, prioritize closing the most profitable position that contributes to the exceeded OI (e.g., if long OI is exceeded, close the most profitable long position).",
        "type": "object",
        "required": [
          "deleverage"
        ],
        "properties": {
          "deleverage": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Receive updated parameters from the params contract",
        "type": "object",
        "required": [
          "update_params"
        ],
        "properties": {
          "update_params": {
            "type": "object",
            "required": [
              "params"
            ],
            "properties": {
              "params": {
                "$ref": "#/definitions/PerpParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ActionKind": {
        "description": "Differentiator for the action (liquidate, withdraw, borrow etc.) being performed.",
        "type": "string",
        "enum": [
          "default",
          "liquidation"
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "OwnerUpdate": {
        "oneOf": [
          {
            "description": "Proposes a new owner to take role. Only current owner can execute.",
            "type": "object",
            "required": [
              "propose_new_owner"
            ],
            "properties": {
              "propose_new_owner": {
                "type": "object",
                "required": [
                  "proposed"
                ],
                "properties": {
                  "proposed": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the currently proposed owner. Only current owner can execute.",
            "type": "string",
            "enum": [
              "clear_proposed"
            ]
          },
          {
            "description": "Promotes the proposed owner to be the current one. Only the proposed owner can execute.",
            "type": "string",
            "enum": [
              "accept_proposed"
            ]
          },
          {
            "description": "Throws away the keys to the Owner role forever. Once done, no owner can ever be set later.",
            "type": "string",
            "enum": [
              "abolish_owner_role"
            ]
          },
          {
            "description": "A separate entity managed by Owner that can be used for granting specific emergency powers.",
            "type": "object",
            "required": [
              "set_emergency_owner"
            ],
            "properties": {
              "set_emergency_owner": {
                "type": "object",
                "required": [
                  "emergency_owner"
                ],
                "properties": {
                  "emergency_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove the entity in the Emergency Owner role",
            "type": "string",
            "enum": [
              "clear_emergency_owner"
            ]
          }
        ]
      },
      "PerpParams": {
        "type": "object",
        "required": [
          "closing_fee_rate",
          "denom",
          "enabled",
          "liquidation_threshold",
          "max_funding_velocity",
          "max_loan_to_value",
          "max_long_oi_value",
          "max_net_oi_value",
          "max_short_oi_value",
          "min_position_value",
          "opening_fee_rate",
          "skew_scale"
        ],
        "properties": {
          "closing_fee_rate": {
            "description": "The fee paid by the user to close a position (as a percent)",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "denom": {
            "description": "Perp denomination",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the perp is enabled",
            "type": "boolean"
          },
          "liquidation_threshold": {
            "description": "LTV at which a position becomes liquidatable",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "max_funding_velocity": {
            "description": "Determines the maximum rate at which funding can be adjusted",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "max_loan_to_value": {
            "description": "Max loan to position value for the position.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "max_long_oi_value": {
            "description": "The maximum long open interest value (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_net_oi_value": {
            "description": "The maximum net open interest value (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_position_value": {
            "description": "The maximum value of a position (in oracle uusd denomination)",
            "anyOf": [
              {
                "$ref": "#/definitions/Uint128"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_short_oi_value": {
            "description": "The maximum short open interest value (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "min_position_value": {
            "description": "The minimum value of a position (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "opening_fee_rate": {
            "description": "The fee paid by the user to open a position (as a percent)",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "skew_scale": {
            "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SignedUint": {
        "type": "object",
        "required": [
          "abs",
          "negative"
        ],
        "properties": {
          "abs": {
            "$ref": "#/definitions/Uint128"
          },
          "negative": {
            "type": "boolean"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "vault"
        ],
        "properties": {
          "vault": {
            "type": "object",
            "properties": {
              "action": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ActionKind"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_state"
        ],
        "properties": {
          "denom_state": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp denom state with current calculated PnL, funding etc.",
        "type": "object",
        "required": [
          "perp_denom_state"
        ],
        "properties": {
          "perp_denom_state": {
            "type": "object",
            "required": [
              "action",
              "denom"
            ],
            "properties": {
              "action": {
                "$ref": "#/definitions/ActionKind"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp denom state with current calculated PnL, funding etc.",
        "type": "object",
        "required": [
          "perp_denom_states"
        ],
        "properties": {
          "perp_denom_states": {
            "type": "object",
            "required": [
              "action"
            ],
            "properties": {
              "action": {
                "$ref": "#/definitions/ActionKind"
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List all denoms enabled for trading",
        "type": "object",
        "required": [
          "denom_states"
        ],
        "properties": {
          "denom_states": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "perp_vault_position"
        ],
        "properties": {
          "perp_vault_position": {
            "type": "object",
            "required": [
              "user_address"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "action": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ActionKind"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "user_address": {
                "description": "User address calling the contract. It can be the Credit Manager contract or a wallet.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the amount of deposit made to the vault by a single user",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "required": [
              "user_address"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "user_address": {
                "description": "User address calling the contract. It can be the Credit Manager contract or a wallet.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unlocks"
        ],
        "properties": {
          "unlocks": {
            "type": "object",
            "required": [
              "user_address"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "user_address": {
                "description": "User address calling the contract. It can be the Credit Manager contract or a wallet.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp position by ID",
        "type": "object",
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "order_size": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/SignedUint"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all accounts and denoms",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all denoms that belong to a specific credit account.\n\nNOTE: This query does not take a pagination parameter. It always returns _all_ perp positions that belong to the given account.",
        "type": "object",
        "required": [
          "positions_by_account"
        ],
        "properties": {
          "positions_by_account": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "action": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ActionKind"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Compute the total PnL of all perp positions, denominated in uusd (USD = 1e6 uusd, configured in Oracle)",
        "type": "object",
        "required": [
          "total_pnl"
        ],
        "properties": {
          "total_pnl": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "opening_fee"
        ],
        "properties": {
          "opening_fee": {
            "type": "object",
            "required": [
              "denom",
              "size"
            ],
            "properties": {
              "denom": {
                "type": "string"
              },
              "size": {
                "$ref": "#/definitions/SignedUint"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_accounting"
        ],
        "properties": {
          "denom_accounting": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "total_accounting"
        ],
        "properties": {
          "total_accounting": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_realized_pnl_for_account"
        ],
        "properties": {
          "denom_realized_pnl_for_account": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "position_fees"
        ],
        "properties": {
          "position_fees": {
            "type": "object",
            "required": [
              "account_id",
              "denom",
              "new_size"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "new_size": {
                "$ref": "#/definitions/SignedUint"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ActionKind": {
        "description": "Differentiator for the action (liquidate, withdraw, borrow etc.) being performed.",
        "type": "string",
        "enum": [
          "default",
          "liquidation"
        ]
      },
      "SignedUint": {
        "type": "object",
        "required": [
          "abs",
          "negative"
        ],
        "properties": {
          "abs": {
            "$ref": "#/definitions/Uint128"
          },
          "negative": {
            "type": "boolean"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config_for_String",
      "description": "The perp protocol's global configuration",
      "type": "object",
      "required": [
        "address_provider",
        "base_denom",
        "cooldown_period",
        "credit_manager",
        "max_positions",
        "oracle",
        "params",
        "protocol_fee_rate",
        "target_vault_collaterization_ratio"
      ],
      "properties": {
        "address_provider": {
          "description": "Address provider returns addresses for all protocol contracts",
          "type": "string"
        },
        "base_denom": {
          "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
          "type": "string"
        },
        "cooldown_period": {
          "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "credit_manager": {
          "description": "Address of the Mars Rover credit manager (CM) contract.\n\nUsers open, modify, or close perp positions by interacting with the CM. The CM then invokes the appropriate execute method(s) on the perps contract to fulfill the user requests.",
          "type": "string"
        },
        "max_positions": {
          "description": "The maximum number of positions that can be opened by a single user",
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        },
        "oracle": {
          "description": "Adapter for interacting with the Mars oracle contract",
          "allOf": [
            {
              "$ref": "#/definitions/OracleBase_for_String"
            }
          ]
        },
        "params": {
          "description": "Adapter for interacting with the Mars params contract",
          "allOf": [
            {
              "$ref": "#/definitions/ParamsBase_for_String"
            }
          ]
        },
        "protocol_fee_rate": {
          "description": "The percentage of fees that is directed to the protocol",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "target_vault_collaterization_ratio": {
          "description": "The target collateralization ratio of the vault",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "OracleBase_for_String": {
          "type": "string"
        },
        "ParamsBase_for_String": {
          "type": "string"
        }
      }
    },
    "denom_accounting": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Accounting",
      "description": "Accounting in the base denom (e.g. UUSDC)",
      "type": "object",
      "required": [
        "balance",
        "cash_flow",
        "withdrawal_balance"
      ],
      "properties": {
        "balance": {
          "description": "The actual amount of money + unrealized payments",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        },
        "cash_flow": {
          "description": "The actual amount of money, includes only realized payments",
          "allOf": [
            {
              "$ref": "#/definitions/CashFlow"
            }
          ]
        },
        "withdrawal_balance": {
          "description": "The amount of money available for withdrawal by LPs (in this type of balance we cap some unrealized payments)",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Balance": {
          "description": "Amount of money denominated in the base denom (e.g. UUSDC) used for accounting",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl",
            "total"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "opening_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            },
            "total": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "CashFlow": {
          "description": "The actual amount of money denominated in the base denom (e.g. UUSDC), includes only realized payments",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "opening_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "denom_realized_pnl_for_account": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PnlAmounts",
      "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
      "type": "object",
      "required": [
        "accrued_funding",
        "closing_fee",
        "opening_fee",
        "pnl",
        "price_pnl"
      ],
      "properties": {
        "accrued_funding": {
          "$ref": "#/definitions/SignedUint"
        },
        "closing_fee": {
          "$ref": "#/definitions/SignedUint"
        },
        "opening_fee": {
          "$ref": "#/definitions/SignedUint"
        },
        "pnl": {
          "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
          "allOf": [
            {
              "$ref": "#/definitions/SignedUint"
            }
          ]
        },
        "price_pnl": {
          "$ref": "#/definitions/SignedUint"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "denom_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DenomStateResponse",
      "type": "object",
      "required": [
        "denom",
        "enabled",
        "funding",
        "last_updated",
        "total_cost_base"
      ],
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "funding": {
          "$ref": "#/definitions/Funding"
        },
        "last_updated": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "total_cost_base": {
          "$ref": "#/definitions/SignedUint"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "last_funding_accrued_per_unit_in_base_denom",
            "last_funding_rate",
            "max_funding_velocity",
            "skew_scale"
          ],
          "properties": {
            "last_funding_accrued_per_unit_in_base_denom": {
              "description": "Last funding accrued per unit",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "last_funding_rate": {
              "description": "The current funding rate calculated as an 24-hour rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "denom_states": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_DenomStateResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/DenomStateResponse"
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "DenomStateResponse": {
          "type": "object",
          "required": [
            "denom",
            "enabled",
            "funding",
            "last_updated",
            "total_cost_base"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "enabled": {
              "type": "boolean"
            },
            "funding": {
              "$ref": "#/definitions/Funding"
            },
            "last_updated": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "total_cost_base": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "last_funding_accrued_per_unit_in_base_denom",
            "last_funding_rate",
            "max_funding_velocity",
            "skew_scale"
          ],
          "properties": {
            "last_funding_accrued_per_unit_in_base_denom": {
              "description": "Last funding accrued per unit",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "last_funding_rate": {
              "description": "The current funding rate calculated as an 24-hour rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "deposit": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PerpVaultDeposit",
      "type": "object",
      "required": [
        "amount",
        "shares"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "shares": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "opening_fee": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TradingFee",
      "type": "object",
      "required": [
        "fee",
        "rate"
      ],
      "properties": {
        "fee": {
          "$ref": "#/definitions/Coin"
        },
        "rate": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OwnerResponse",
      "description": "Returned from Owner.query()",
      "type": "object",
      "required": [
        "abolished",
        "initialized"
      ],
      "properties": {
        "abolished": {
          "type": "boolean"
        },
        "emergency_owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "initialized": {
          "type": "boolean"
        },
        "owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "proposed": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "perp_denom_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PerpDenomState",
      "description": "This is the denom data to be returned in a query. It includes current price, PnL and funding.",
      "type": "object",
      "required": [
        "denom",
        "enabled",
        "funding",
        "long_oi",
        "pnl_values",
        "rate",
        "short_oi",
        "total_entry_cost",
        "total_entry_funding"
      ],
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "funding": {
          "$ref": "#/definitions/Funding"
        },
        "long_oi": {
          "$ref": "#/definitions/Uint128"
        },
        "pnl_values": {
          "$ref": "#/definitions/PnlValues"
        },
        "rate": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "short_oi": {
          "$ref": "#/definitions/Uint128"
        },
        "total_entry_cost": {
          "$ref": "#/definitions/SignedUint"
        },
        "total_entry_funding": {
          "$ref": "#/definitions/SignedUint"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "last_funding_accrued_per_unit_in_base_denom",
            "last_funding_rate",
            "max_funding_velocity",
            "skew_scale"
          ],
          "properties": {
            "last_funding_accrued_per_unit_in_base_denom": {
              "description": "Last funding accrued per unit",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "last_funding_rate": {
              "description": "The current funding rate calculated as an 24-hour rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PnlValues": {
          "description": "Values denominated in the Oracle base currency (uusd)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedUint"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "perp_denom_states": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PaginationResponse_for_PerpDenomState",
      "type": "object",
      "required": [
        "data",
        "metadata"
      ],
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PerpDenomState"
          }
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "last_funding_accrued_per_unit_in_base_denom",
            "last_funding_rate",
            "max_funding_velocity",
            "skew_scale"
          ],
          "properties": {
            "last_funding_accrued_per_unit_in_base_denom": {
              "description": "Last funding accrued per unit",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "last_funding_rate": {
              "description": "The current funding rate calculated as an 24-hour rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Metadata": {
          "type": "object",
          "required": [
            "has_more"
          ],
          "properties": {
            "has_more": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "PerpDenomState": {
          "description": "This is the denom data to be returned in a query. It includes current price, PnL and funding.",
          "type": "object",
          "required": [
            "denom",
            "enabled",
            "funding",
            "long_oi",
            "pnl_values",
            "rate",
            "short_oi",
            "total_entry_cost",
            "total_entry_funding"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "enabled": {
              "type": "boolean"
            },
            "funding": {
              "$ref": "#/definitions/Funding"
            },
            "long_oi": {
              "$ref": "#/definitions/Uint128"
            },
            "pnl_values": {
              "$ref": "#/definitions/PnlValues"
            },
            "rate": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "short_oi": {
              "$ref": "#/definitions/Uint128"
            },
            "total_entry_cost": {
              "$ref": "#/definitions/SignedUint"
            },
            "total_entry_funding": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "PnlValues": {
          "description": "Values denominated in the Oracle base currency (uusd)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedUint"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "perp_vault_position": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_PerpVaultPosition",
      "anyOf": [
        {
          "$ref": "#/definitions/PerpVaultPosition"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "PerpVaultDeposit": {
          "type": "object",
          "required": [
            "amount",
            "shares"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "PerpVaultPosition": {
          "type": "object",
          "required": [
            "denom",
            "deposit",
            "unlocks"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "deposit": {
              "$ref": "#/definitions/PerpVaultDeposit"
            },
            "unlocks": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/PerpVaultUnlock"
              }
            }
          },
          "additionalProperties": false
        },
        "PerpVaultUnlock": {
          "type": "object",
          "required": [
            "amount",
            "cooldown_end",
            "created_at",
            "shares"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "cooldown_end": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "position": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionResponse",
      "type": "object",
      "required": [
        "account_id"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "position": {
          "anyOf": [
            {
              "$ref": "#/definitions/PerpPosition"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_exec_price",
            "current_price",
            "denom",
            "entry_exec_price",
            "entry_price",
            "realised_pnl",
            "size",
            "unrealised_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realised_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            },
            "size": {
              "$ref": "#/definitions/SignedUint"
            },
            "unrealised_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            }
          },
          "additionalProperties": false
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "opening_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedUint"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "position_fees": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionFeesResponse",
      "type": "object",
      "required": [
        "base_denom",
        "closing_fee",
        "opening_fee"
      ],
      "properties": {
        "base_denom": {
          "description": "Denomination of the base asset",
          "type": "string"
        },
        "closing_exec_price": {
          "description": "Closing execution price of the position calculated with: - entry size if the position is closed or reduced",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "closing_fee": {
          "description": "The fee charged when closing/reducing a position",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "opening_exec_price": {
          "description": "Opening execution price of the position calculated with: - entry size if the position is opened - new size if the position is increased or reduced",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "opening_fee": {
          "description": "The fee charged when opening/increasing a position",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PositionResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PositionResponse"
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_exec_price",
            "current_price",
            "denom",
            "entry_exec_price",
            "entry_price",
            "realised_pnl",
            "size",
            "unrealised_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realised_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            },
            "size": {
              "$ref": "#/definitions/SignedUint"
            },
            "unrealised_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            }
          },
          "additionalProperties": false
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "opening_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedUint"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "PositionResponse": {
          "type": "object",
          "required": [
            "account_id"
          ],
          "properties": {
            "account_id": {
              "type": "string"
            },
            "position": {
              "anyOf": [
                {
                  "$ref": "#/definitions/PerpPosition"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions_by_account": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionsByAccountResponse",
      "type": "object",
      "required": [
        "account_id",
        "positions"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "positions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PerpPosition"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_exec_price",
            "current_price",
            "denom",
            "entry_exec_price",
            "entry_price",
            "realised_pnl",
            "size",
            "unrealised_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realised_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            },
            "size": {
              "$ref": "#/definitions/SignedUint"
            },
            "unrealised_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            }
          },
          "additionalProperties": false
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "opening_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedUint"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "total_accounting": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Accounting",
      "description": "Accounting in the base denom (e.g. UUSDC)",
      "type": "object",
      "required": [
        "balance",
        "cash_flow",
        "withdrawal_balance"
      ],
      "properties": {
        "balance": {
          "description": "The actual amount of money + unrealized payments",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        },
        "cash_flow": {
          "description": "The actual amount of money, includes only realized payments",
          "allOf": [
            {
              "$ref": "#/definitions/CashFlow"
            }
          ]
        },
        "withdrawal_balance": {
          "description": "The amount of money available for withdrawal by LPs (in this type of balance we cap some unrealized payments)",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Balance": {
          "description": "Amount of money denominated in the base denom (e.g. UUSDC) used for accounting",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl",
            "total"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "opening_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            },
            "total": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "CashFlow": {
          "description": "The actual amount of money denominated in the base denom (e.g. UUSDC), includes only realized payments",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedUint"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "opening_fee": {
              "$ref": "#/definitions/SignedUint"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedUint"
            }
          },
          "additionalProperties": false
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "total_pnl": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SignedDecimal",
      "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
      "type": "object",
      "required": [
        "abs",
        "negative"
      ],
      "properties": {
        "abs": {
          "$ref": "#/definitions/Decimal"
        },
        "negative": {
          "type": "boolean"
        }
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "unlocks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PerpVaultUnlock",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PerpVaultUnlock"
      },
      "definitions": {
        "PerpVaultUnlock": {
          "type": "object",
          "required": [
            "amount",
            "cooldown_end",
            "created_at",
            "shares"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "cooldown_end": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "vault": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VaultResponse",
      "type": "object",
      "required": [
        "total_balance",
        "total_debt",
        "total_liquidity",
        "total_shares",
        "total_withdrawal_balance"
      ],
      "properties": {
        "collateralization_ratio": {
          "description": "Collateralization ratio of the vault. `collateralization_ratio = total_liquidity / total_debt` None if `total_debt` is zero.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "share_price": {
          "description": "Vault share price is calculated directly from the total withdrawal balance and the shares supply. `share_price = total_withdrawal_balance / total_shares` None if `total_shares` is zero.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "total_balance": {
          "description": "Value of the total balance in the base denom. This is the total amount of the base denom deposited to the vault by liquidity providers. The value is updated when a user deposits or withdraws from the vault. The value can be negative if the liquidity providers withdraw more than the total balance. This can happen if the vault earns a profit from trading.",
          "allOf": [
            {
              "$ref": "#/definitions/SignedUint"
            }
          ]
        },
        "total_debt": {
          "description": "Positive total unrealized PnL that the vault owes to the users. `total_debt = max(total_unrealized_pnl, 0)`",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_liquidity": {
          "description": "Total liquidity in the base denom aggregated across all markets. `total_liquidity = max(total_balance + accounting.liquidity.total, 0)` See [`Accounting`] for more details regarding the calculation of `accounting.liquidity.total`.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_shares": {
          "description": "Total shares minted to liquidity providers.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_withdrawal_balance": {
          "description": "Total withdrawal balance in the base denom aggregated across all markets. `total_withdrawal_balance = max(total_balance + accounting.withdrawal_balance.total, 0)` See [`Accounting`] for more details regarding the calculation of `accounting.withdrawal_balance.total`.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "SignedUint": {
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Uint128"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
