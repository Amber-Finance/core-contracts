{
  "contract_name": "mars-perps",
  "contract_version": "2.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The perp protocol's global configuration",
    "type": "object",
    "required": [
      "base_denom",
      "closing_fee_rate",
      "cooldown_period",
      "credit_manager",
      "min_position_in_base_denom",
      "opening_fee_rate",
      "oracle",
      "params"
    ],
    "properties": {
      "base_denom": {
        "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
        "type": "string"
      },
      "closing_fee_rate": {
        "description": "The fee rate charged when closing a position",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "cooldown_period": {
        "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "credit_manager": {
        "description": "Address of the Mars Rover credit manager (CM) contract.\n\nUsers open, modify, or close perp positions by interacting with the CM. The CM then invokes the appropriate execute method(s) on the perps contract to fulfill the user requests.",
        "type": "string"
      },
      "max_position_in_base_denom": {
        "description": "The maximum value of a position, in the base asset (i.e. USDC).",
        "anyOf": [
          {
            "$ref": "#/definitions/Uint128"
          },
          {
            "type": "null"
          }
        ]
      },
      "min_position_in_base_denom": {
        "description": "The minimum value of a position, in the base asset (i.e. USDC).",
        "allOf": [
          {
            "$ref": "#/definitions/Uint128"
          }
        ]
      },
      "opening_fee_rate": {
        "description": "The fee rate charged when opening a new position",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "oracle": {
        "description": "Adapter for interacting with the Mars oracle contract",
        "allOf": [
          {
            "$ref": "#/definitions/OracleBase_for_String"
          }
        ]
      },
      "params": {
        "description": "Adapter for interacting with the Mars params contract",
        "allOf": [
          {
            "$ref": "#/definitions/ParamsBase_for_String"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "OracleBase_for_String": {
        "type": "string"
      },
      "ParamsBase_for_String": {
        "type": "string"
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "update_owner"
        ],
        "properties": {
          "update_owner": {
            "$ref": "#/definitions/OwnerUpdate"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Init a denom to be traded.\n\nOnly callable by the owner.",
        "type": "object",
        "required": [
          "init_denom"
        ],
        "properties": {
          "init_denom": {
            "type": "object",
            "required": [
              "denom",
              "max_funding_velocity",
              "skew_scale"
            ],
            "properties": {
              "denom": {
                "type": "string"
              },
              "max_funding_velocity": {
                "$ref": "#/definitions/Decimal"
              },
              "skew_scale": {
                "$ref": "#/definitions/Decimal"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enable a denom to be traded.\n\nOnly callable by the owner.",
        "type": "object",
        "required": [
          "enable_denom"
        ],
        "properties": {
          "enable_denom": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Disable a denom from being traded.\n\nOnce disabled, perp positions with this denom can only be closed.\n\nOnly callable by the owner.",
        "type": "object",
        "required": [
          "disable_denom"
        ],
        "properties": {
          "disable_denom": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Provide liquidity of the base token to the vault.\n\nMust send exactly one coin of `base_denom`.\n\nThe deposited tokens will be used to settle perp trades. liquidity providers win if traders have negative PnLs, or loss if traders have positive PnLs.",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unlock liquidity from the vault. The unlocked tokens will have to wait a cooldown period before they can be withdrawn.",
        "type": "object",
        "required": [
          "unlock"
        ],
        "properties": {
          "unlock": {
            "type": "object",
            "required": [
              "shares"
            ],
            "properties": {
              "shares": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw liquidity from the vault.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Open a new perp position.\n\nOnly callable by Rover credit manager.\n\nMust send exactly one coin of `base_denom`.",
        "type": "object",
        "required": [
          "open_position"
        ],
        "properties": {
          "open_position": {
            "type": "object",
            "required": [
              "account_id",
              "denom",
              "size"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID",
                "type": "string"
              },
              "denom": {
                "description": "Name of the trading pair",
                "type": "string"
              },
              "size": {
                "description": "Size of the position, denominated in the traded asset.\n\nA positive number means the position is long, a negative number means it's short.\n\nMust be greater than the minimum position size set at the protocol level.",
                "allOf": [
                  {
                    "$ref": "#/definitions/SignedDecimal"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Close a perp position. Return collateral + unrealized PnL to the user's credit account.\n\nOnly callable by Rover credit manager.",
        "type": "object",
        "required": [
          "close_position"
        ],
        "properties": {
          "close_position": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Modify a perp position.",
        "type": "object",
        "required": [
          "modify_position"
        ],
        "properties": {
          "modify_position": {
            "type": "object",
            "required": [
              "account_id",
              "denom",
              "new_size"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "new_size": {
                "description": "To increase a long or reduce a short, this will be positive To decrease a long or increase a short, this will be negative",
                "allOf": [
                  {
                    "$ref": "#/definitions/SignedDecimal"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "OwnerUpdate": {
        "oneOf": [
          {
            "description": "Proposes a new owner to take role. Only current owner can execute.",
            "type": "object",
            "required": [
              "propose_new_owner"
            ],
            "properties": {
              "propose_new_owner": {
                "type": "object",
                "required": [
                  "proposed"
                ],
                "properties": {
                  "proposed": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the currently proposed owner. Only current owner can execute.",
            "type": "string",
            "enum": [
              "clear_proposed"
            ]
          },
          {
            "description": "Promotes the proposed owner to be the current one. Only the proposed owner can execute.",
            "type": "string",
            "enum": [
              "accept_proposed"
            ]
          },
          {
            "description": "Throws away the keys to the Owner role forever. Once done, no owner can ever be set later.",
            "type": "string",
            "enum": [
              "abolish_owner_role"
            ]
          },
          {
            "description": "A separate entity managed by Owner that can be used for granting specific emergency powers.",
            "type": "object",
            "required": [
              "set_emergency_owner"
            ],
            "properties": {
              "set_emergency_owner": {
                "type": "object",
                "required": [
                  "emergency_owner"
                ],
                "properties": {
                  "emergency_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove the entity in the Emergency Owner role",
            "type": "string",
            "enum": [
              "clear_emergency_owner"
            ]
          }
        ]
      },
      "SignedDecimal": {
        "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
        "type": "object",
        "required": [
          "abs",
          "negative"
        ],
        "properties": {
          "abs": {
            "$ref": "#/definitions/Decimal"
          },
          "negative": {
            "type": "boolean"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "vault_state"
        ],
        "properties": {
          "vault_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_state"
        ],
        "properties": {
          "denom_state": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp denom state with current calculated PnL, funding etc.",
        "type": "object",
        "required": [
          "perp_denom_state"
        ],
        "properties": {
          "perp_denom_state": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List all denoms enabled for trading",
        "type": "object",
        "required": [
          "denom_states"
        ],
        "properties": {
          "denom_states": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the amount of deposit made to the vault by a single user",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "required": [
              "depositor"
            ],
            "properties": {
              "depositor": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List all deposits to the vault",
        "type": "object",
        "required": [
          "deposits"
        ],
        "properties": {
          "deposits": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unlocks"
        ],
        "properties": {
          "unlocks": {
            "type": "object",
            "required": [
              "depositor"
            ],
            "properties": {
              "depositor": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp position by ID",
        "type": "object",
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all accounts and denoms",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all denoms that belong to a specific credit account.\n\nNOTE: This query does not take a pagination parameter. It always returns _all_ perp positions that belong to the given account.",
        "type": "object",
        "required": [
          "positions_by_account"
        ],
        "properties": {
          "positions_by_account": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Compute the total PnL of all perp positions, denominated in uusd (USD = 1e6 uusd, configured in Oracle)",
        "type": "object",
        "required": [
          "total_pnl"
        ],
        "properties": {
          "total_pnl": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "opening_fee"
        ],
        "properties": {
          "opening_fee": {
            "type": "object",
            "required": [
              "denom",
              "size"
            ],
            "properties": {
              "denom": {
                "type": "string"
              },
              "size": {
                "$ref": "#/definitions/SignedDecimal"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_accounting"
        ],
        "properties": {
          "denom_accounting": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "total_accounting"
        ],
        "properties": {
          "total_accounting": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_realized_pnl_for_account"
        ],
        "properties": {
          "denom_realized_pnl_for_account": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "SignedDecimal": {
        "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
        "type": "object",
        "required": [
          "abs",
          "negative"
        ],
        "properties": {
          "abs": {
            "$ref": "#/definitions/Decimal"
          },
          "negative": {
            "type": "boolean"
          }
        }
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config_for_String",
      "description": "The perp protocol's global configuration",
      "type": "object",
      "required": [
        "base_denom",
        "closing_fee_rate",
        "cooldown_period",
        "credit_manager",
        "min_position_in_base_denom",
        "opening_fee_rate",
        "oracle",
        "params"
      ],
      "properties": {
        "base_denom": {
          "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
          "type": "string"
        },
        "closing_fee_rate": {
          "description": "The fee rate charged when closing a position",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "cooldown_period": {
          "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "credit_manager": {
          "description": "Address of the Mars Rover credit manager (CM) contract.\n\nUsers open, modify, or close perp positions by interacting with the CM. The CM then invokes the appropriate execute method(s) on the perps contract to fulfill the user requests.",
          "type": "string"
        },
        "max_position_in_base_denom": {
          "description": "The maximum value of a position, in the base asset (i.e. USDC).",
          "anyOf": [
            {
              "$ref": "#/definitions/Uint128"
            },
            {
              "type": "null"
            }
          ]
        },
        "min_position_in_base_denom": {
          "description": "The minimum value of a position, in the base asset (i.e. USDC).",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "opening_fee_rate": {
          "description": "The fee rate charged when opening a new position",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "oracle": {
          "description": "Adapter for interacting with the Mars oracle contract",
          "allOf": [
            {
              "$ref": "#/definitions/OracleBase_for_String"
            }
          ]
        },
        "params": {
          "description": "Adapter for interacting with the Mars params contract",
          "allOf": [
            {
              "$ref": "#/definitions/ParamsBase_for_String"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "OracleBase_for_String": {
          "type": "string"
        },
        "ParamsBase_for_String": {
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "denom_accounting": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Accounting",
      "description": "Accounting in the base denom (e.g. UUSDC)",
      "type": "object",
      "required": [
        "balance",
        "cash_flow",
        "withdrawal_balance"
      ],
      "properties": {
        "balance": {
          "description": "The actual amount of money + unrealized payments",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        },
        "cash_flow": {
          "description": "The actual amount of money, includes only realized payments",
          "allOf": [
            {
              "$ref": "#/definitions/CashFlow"
            }
          ]
        },
        "withdrawal_balance": {
          "description": "The amount of money available for withdrawal by LPs (in this type of balance we cap some unrealized payments)",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Balance": {
          "description": "Amount of money denominated in the base denom (e.g. UUSDC) used for accounting",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fees",
            "opening_fees",
            "price_pnl",
            "total"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "opening_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "total": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "CashFlow": {
          "description": "The actual amount of money denominated in the base denom (e.g. UUSDC), includes only realized payments",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fees",
            "opening_fees",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "opening_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "denom_realized_pnl_for_account": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RealizedPnlAmounts",
      "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
      "type": "object",
      "required": [
        "accrued_funding",
        "closing_fee",
        "opening_fee",
        "pnl",
        "price_pnl"
      ],
      "properties": {
        "accrued_funding": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "closing_fee": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "opening_fee": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "pnl": {
          "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
          "allOf": [
            {
              "$ref": "#/definitions/SignedDecimal"
            }
          ]
        },
        "price_pnl": {
          "$ref": "#/definitions/SignedDecimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "denom_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DenomStateResponse",
      "type": "object",
      "required": [
        "denom",
        "enabled",
        "funding",
        "last_updated",
        "total_cost_base"
      ],
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "funding": {
          "$ref": "#/definitions/Funding"
        },
        "last_updated": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "total_cost_base": {
          "$ref": "#/definitions/SignedDecimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "last_funding_accrued_per_unit_in_base_denom",
            "last_funding_rate",
            "max_funding_velocity",
            "skew_scale"
          ],
          "properties": {
            "last_funding_accrued_per_unit_in_base_denom": {
              "description": "Last funding accrued per unit",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "last_funding_rate": {
              "description": "The current funding rate calculated as an 24-hour rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "denom_states": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_DenomStateResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/DenomStateResponse"
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "DenomStateResponse": {
          "type": "object",
          "required": [
            "denom",
            "enabled",
            "funding",
            "last_updated",
            "total_cost_base"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "enabled": {
              "type": "boolean"
            },
            "funding": {
              "$ref": "#/definitions/Funding"
            },
            "last_updated": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "total_cost_base": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "last_funding_accrued_per_unit_in_base_denom",
            "last_funding_rate",
            "max_funding_velocity",
            "skew_scale"
          ],
          "properties": {
            "last_funding_accrued_per_unit_in_base_denom": {
              "description": "Last funding accrued per unit",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "last_funding_rate": {
              "description": "The current funding rate calculated as an 24-hour rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "deposit": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DepositResponse",
      "type": "object",
      "required": [
        "amount",
        "depositor",
        "shares"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "depositor": {
          "type": "string"
        },
        "shares": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "deposits": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_DepositResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/DepositResponse"
      },
      "definitions": {
        "DepositResponse": {
          "type": "object",
          "required": [
            "amount",
            "depositor",
            "shares"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "depositor": {
              "type": "string"
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "opening_fee": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TradingFee",
      "type": "object",
      "required": [
        "fee",
        "rate"
      ],
      "properties": {
        "fee": {
          "$ref": "#/definitions/Coin"
        },
        "rate": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OwnerResponse",
      "description": "Returned from Owner.query()",
      "type": "object",
      "required": [
        "abolished",
        "initialized"
      ],
      "properties": {
        "abolished": {
          "type": "boolean"
        },
        "emergency_owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "initialized": {
          "type": "boolean"
        },
        "owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "proposed": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "perp_denom_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PerpDenomState",
      "description": "This is the denom data to be returned in a query. It includes current price, PnL and funding.",
      "type": "object",
      "required": [
        "denom",
        "enabled",
        "pnl_values",
        "rate",
        "total_entry_cost",
        "total_entry_funding"
      ],
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "pnl_values": {
          "$ref": "#/definitions/DenomPnlValues"
        },
        "rate": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "total_entry_cost": {
          "$ref": "#/definitions/SignedDecimal"
        },
        "total_entry_funding": {
          "$ref": "#/definitions/SignedDecimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "DenomPnlValues": {
          "description": "PnL values denominated in the base currency",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fees",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "pnl": {
              "description": "The total PnL: price_pnl + closing_fees + accrued_funding",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "position": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionResponse",
      "type": "object",
      "required": [
        "account_id",
        "position"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "position": {
          "$ref": "#/definitions/PerpPosition"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_price",
            "denom",
            "entry_price",
            "realised_pnl",
            "size",
            "unrealised_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realised_pnl": {
              "$ref": "#/definitions/PnlValues"
            },
            "size": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "unrealised_pnl": {
              "$ref": "#/definitions/PositionPnl"
            }
          },
          "additionalProperties": false
        },
        "PnL": {
          "description": "The profit-and-loss of a perp position, denominated in the base currency.",
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "break_even"
              ]
            },
            {
              "type": "object",
              "required": [
                "profit"
              ],
              "properties": {
                "profit": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "loss"
              ],
              "properties": {
                "loss": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PnlCoins": {
          "description": "Coins with Perp Vault base denom (uusdc) as a denom",
          "type": "object",
          "required": [
            "closing_fee",
            "pnl"
          ],
          "properties": {
            "closing_fee": {
              "$ref": "#/definitions/Coin"
            },
            "pnl": {
              "$ref": "#/definitions/PnL"
            }
          },
          "additionalProperties": false
        },
        "PnlValues": {
          "description": "Values denominated in the Oracle base currency (uusd)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "PositionPnl": {
          "type": "object",
          "required": [
            "coins",
            "values"
          ],
          "properties": {
            "coins": {
              "$ref": "#/definitions/PnlCoins"
            },
            "values": {
              "$ref": "#/definitions/PnlValues"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PositionResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PositionResponse"
      },
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_price",
            "denom",
            "entry_price",
            "realised_pnl",
            "size",
            "unrealised_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realised_pnl": {
              "$ref": "#/definitions/PnlValues"
            },
            "size": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "unrealised_pnl": {
              "$ref": "#/definitions/PositionPnl"
            }
          },
          "additionalProperties": false
        },
        "PnL": {
          "description": "The profit-and-loss of a perp position, denominated in the base currency.",
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "break_even"
              ]
            },
            {
              "type": "object",
              "required": [
                "profit"
              ],
              "properties": {
                "profit": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "loss"
              ],
              "properties": {
                "loss": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PnlCoins": {
          "description": "Coins with Perp Vault base denom (uusdc) as a denom",
          "type": "object",
          "required": [
            "closing_fee",
            "pnl"
          ],
          "properties": {
            "closing_fee": {
              "$ref": "#/definitions/Coin"
            },
            "pnl": {
              "$ref": "#/definitions/PnL"
            }
          },
          "additionalProperties": false
        },
        "PnlValues": {
          "description": "Values denominated in the Oracle base currency (uusd)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "PositionPnl": {
          "type": "object",
          "required": [
            "coins",
            "values"
          ],
          "properties": {
            "coins": {
              "$ref": "#/definitions/PnlCoins"
            },
            "values": {
              "$ref": "#/definitions/PnlValues"
            }
          },
          "additionalProperties": false
        },
        "PositionResponse": {
          "type": "object",
          "required": [
            "account_id",
            "position"
          ],
          "properties": {
            "account_id": {
              "type": "string"
            },
            "position": {
              "$ref": "#/definitions/PerpPosition"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions_by_account": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionsByAccountResponse",
      "type": "object",
      "required": [
        "account_id",
        "positions"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "positions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PerpPosition"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "closing_fee_rate",
            "current_price",
            "denom",
            "entry_price",
            "realised_pnl",
            "size",
            "unrealised_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "closing_fee_rate": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realised_pnl": {
              "$ref": "#/definitions/PnlValues"
            },
            "size": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "unrealised_pnl": {
              "$ref": "#/definitions/PositionPnl"
            }
          },
          "additionalProperties": false
        },
        "PnL": {
          "description": "The profit-and-loss of a perp position, denominated in the base currency.",
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "break_even"
              ]
            },
            {
              "type": "object",
              "required": [
                "profit"
              ],
              "properties": {
                "profit": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "loss"
              ],
              "properties": {
                "loss": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PnlCoins": {
          "description": "Coins with Perp Vault base denom (uusdc) as a denom",
          "type": "object",
          "required": [
            "closing_fee",
            "pnl"
          ],
          "properties": {
            "closing_fee": {
              "$ref": "#/definitions/Coin"
            },
            "pnl": {
              "$ref": "#/definitions/PnL"
            }
          },
          "additionalProperties": false
        },
        "PnlValues": {
          "description": "Values denominated in the Oracle base currency (uusd)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fee": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "PositionPnl": {
          "type": "object",
          "required": [
            "coins",
            "values"
          ],
          "properties": {
            "coins": {
              "$ref": "#/definitions/PnlCoins"
            },
            "values": {
              "$ref": "#/definitions/PnlValues"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "total_accounting": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Accounting",
      "description": "Accounting in the base denom (e.g. UUSDC)",
      "type": "object",
      "required": [
        "balance",
        "cash_flow",
        "withdrawal_balance"
      ],
      "properties": {
        "balance": {
          "description": "The actual amount of money + unrealized payments",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        },
        "cash_flow": {
          "description": "The actual amount of money, includes only realized payments",
          "allOf": [
            {
              "$ref": "#/definitions/CashFlow"
            }
          ]
        },
        "withdrawal_balance": {
          "description": "The amount of money available for withdrawal by LPs (in this type of balance we cap some unrealized payments)",
          "allOf": [
            {
              "$ref": "#/definitions/Balance"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Balance": {
          "description": "Amount of money denominated in the base denom (e.g. UUSDC) used for accounting",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fees",
            "opening_fees",
            "price_pnl",
            "total"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "opening_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "total": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "CashFlow": {
          "description": "The actual amount of money denominated in the base denom (e.g. UUSDC), includes only realized payments",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fees",
            "opening_fees",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "closing_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "opening_fees": {
              "$ref": "#/definitions/SignedDecimal"
            },
            "price_pnl": {
              "$ref": "#/definitions/SignedDecimal"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "SignedDecimal": {
          "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
          "type": "object",
          "required": [
            "abs",
            "negative"
          ],
          "properties": {
            "abs": {
              "$ref": "#/definitions/Decimal"
            },
            "negative": {
              "type": "boolean"
            }
          }
        }
      }
    },
    "total_pnl": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SignedDecimal",
      "description": "Inspired by Margined protocol's implementation: https://github.com/margined-protocol/perpetuals/blob/main/packages/margined_common/src/integer.rs\n\nThis type is specifically adapted to our need (only methods that are actually used by the contract are implemented) hence not suited for general use.",
      "type": "object",
      "required": [
        "abs",
        "negative"
      ],
      "properties": {
        "abs": {
          "$ref": "#/definitions/Decimal"
        },
        "negative": {
          "type": "boolean"
        }
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "unlocks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_UnlockState",
      "type": "array",
      "items": {
        "$ref": "#/definitions/UnlockState"
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "UnlockState": {
          "description": "Unlock state for a single user",
          "type": "object",
          "required": [
            "amount",
            "cooldown_end",
            "created_at"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "cooldown_end": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "vault_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VaultState",
      "description": "Global state of the counterparty vault",
      "type": "object",
      "required": [
        "total_liquidity",
        "total_shares"
      ],
      "properties": {
        "total_liquidity": {
          "$ref": "#/definitions/Uint128"
        },
        "total_shares": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
